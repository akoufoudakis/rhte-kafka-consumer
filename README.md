# Kafka Consumer

This is a kafka consumer usning spring boot and spring kafka. 

| Technology          |   Reference         |
| -------------       |:-------------:|
| RHOAR               |  <https://access.redhat.com/documentation/en-us/red_hat_openshift_application_runtimes/1/> |
| Spring Boot on OCP  |   <https://access.redhat.com/documentation/en-us/red_hat_openshift_application_runtimes/1/html/spring_boot_runtime_guide/>      |
| Spring Kafka        |  <https://docs.spring.io/spring-kafka/docs/1.3.x/reference/htmlsingle/> |
| Strimzi             | <http://strimzi.io/> |

The idea of this sample is to show both running kafka locally and on OCP
The application flow is consuming the records generated by the producer, after that apply the stateless filters to match the records according to different rules.
The second part is the stateful one, it repartition the filtered record based on credit card number, this ensure that the state store is always having all the record related to the same cc number. We accumulate the transactions related to the same cc and once it reach the target threshold it if add to the illegal transactions topic

#### the logic is splitted into two parts
- using DSL
```java
@SuppressWarnings({"deprecation","unchecked"})
@Bean
public KStream<?, ?> processIncomingStream(KStreamBuilder streamBuilder) {
int LEGAL_TRANS = 0;
int ILLEGAL_TRANS = 1;

KStream<String, CreditCardTransaction> stream = streamBuilder.stream(kafkaTopic);

KStream<String, CreditCardTransaction>[] branchCountriesStream =stream.branch(TransactionPatterns.allowedCountries,TransactionPatterns.bannedCountries);
branchCountriesStream[ILLEGAL_TRANS].to("illegal-trans");

KStream<String, CreditCardTransaction>[] branchTimeOfDayStream =branchCountriesStream[LEGAL_TRANS].branch(TransactionPatterns.ValidHourOfDay,TransactionPatterns.InvalidHourOfDay);
branchTimeOfDayStream[ILLEGAL_TRANS].to("illegal-trans");
stream = branchCountriesStream[LEGAL_TRANS];



CreditCardTransactionPartitioner streamPartitioner = new CreditCardTransactionPartitioner();

//stream.through("by-cc-trans", Produced.with(Serdes.String(), StreamsSerdes.CreditCardTransactionSerde(), streamPartitioner)).to("processed");

stream.to(Serdes.String(), StreamsSerdes.CreditCardTransactionSerde(), streamPartitioner,"by-cc-trans");

return stream;
}
```
- using Processor API
```java
@SuppressWarnings({"deprecation","unchecked"})
@Bean
public KafkaStreams processTransactionsByCreditCardIDStream(TopologyBuilder topologyBuilder,StreamsConfig streamingConfig) {


StateStoreSupplier<KeyValueStore<String, Integer>>  storeSupplier =Stores.create(ccTransactionsStateStoreName)
	    .withKeys(Serdes.String())
	    .withValues(Serdes.Integer())
	    .persistent()
	    .build();
topologyBuilder.addSource(AutoOffsetReset.EARLIEST,"by-cc-trans-source", new WallclockTimestampExtractor(),Serdes.String().deserializer(),StreamsSerdes.CreditCardTransactionSerde().deserializer(),"by-cc-trans")//

//
.addProcessor("ACCUMLATORPROCESSOR", CreditCardTransactionAccumulatorProcessor::new, "by-cc-trans-source")//
.addProcessor("ACCUMLATORFILTERPROCESSOR",CreditCardTransactionAccumulatorFilterProcessor::new , "ACCUMLATORPROCESSOR")
// connect the state store "COUNTS" with processor "ACCUMLATORPROCESSOR"  
.addStateStore(storeSupplier, //
	"ACCUMLATORPROCESSOR")//
.connectProcessorAndStateStores("ACCUMLATORPROCESSOR", ccTransactionsStateStoreName)
//
.addSink("SINK1", "processed",Serdes.String().serializer(),StreamsSerdes.CreditCardTransactionSerde().serializer(), "ACCUMLATORFILTERPROCESSOR")
	.addSink("SINK2", "illegal-trans",Serdes.String().serializer(),StreamsSerdes.CreditCardTransactionSerde().serializer(), "ACCUMLATORFILTERPROCESSOR");

	KafkaStreams streaming = new KafkaStreams(topologyBuilder, streamingConfig);
	return streaming;
}
```
# To run it locally (Not on OCP)
1. Set the application properties to the correct values
2. run the application using the spring boot mvn plugin
```sh
[rhte-kafka-consumer]$ mvn spring-boot:run
```
# To run it on OCP
